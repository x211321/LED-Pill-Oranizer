
// Expected length of intake IDs
#define INTAKE_ID_LEN 19

// Unique length of an intake ID
#define UNIQUE_INTAKE_ID_LEN 17

// Intake events
#define SCHEDULE_MORNING 1
#define SCHEDULE_MIDDAY  2
#define SCHEDULE_EVENING 3
#define SCHEDULE_NIGHT   4

// Intake info indexes
#define SCHEDULE_INFO_WDAY     0
#define SCHEDULE_INFO_LED      1
#define SCHEDULE_INFO_SCHEDULE 2

// Number of LEDs used by the
// intake schedule
// 7 days/week x 4 intake events
#define SCHEDULE_LED_COUNT 28

// Time information
time_t now;
tm tm;

// Number of open confirm requests
// Confirm request are generated by 
// the button interrupt (button.ino)
int confirm_requests = 0;

// Open intakes
// List of intake events
// Intake events are generated 
// when a set intake time is matched
// Intakes are are added at the bottom
// of the list and cleard from the top
DynamicJsonDocument open_intakes(4096);

// Last matched intake ID
// Used to prevent matching of
// Multiple intake
String last_matched_intake_id = "";

// Minutes of the last 
// reminder check
// Used to prevent sending of 
// duplicate reminders
int last_reminder_check_min = 0;

// Flag indicating that
// the PillBox is in refill mode
bool fill_time_active = false;

// ID of last matched refill
String last_matched_refill_id = "";


void init_schedule()
{
  schedule_load();
  schedule_update_time();
  schedule_set_leds();
}


// Central intake handling
void schedule_handle_intake() 
{
  static int count = 0;

  // Handle confirm requests
  while (confirm_requests > 0) {
    confirm_requests--;
    schedule_confirm_last_state();
  }

  // Check for new intakes and reminders
  if (count % 100 == 0) {
    String open_intakes_string;
    schedule_update_time();
    
    debug("\n\nChecking intake: " + schedule_get_current_intake_id());

    schedule_check_for_new_intake();

    debug("Open intake times");
    serializeJson(open_intakes, open_intakes_string);
    debug(" - " + open_intakes_string);

    debug("Last matched intake ID");
    debug(" - " + last_matched_intake_id);

    schedule_online_check_acks();

    schedule_send_open_intake_reminders();
  }

  count++;
}


// Update time information
// Central time structure used
// used by all scheduling operations
void schedule_update_time()
{
    time(&now);
    localtime_r(&now, &tm);
}


// Add a confirm request to the queue
// Triggerd by the interup handler in button.ino
void schedule_addConfirmRequest()
{
  confirm_requests++;
}


// Perform confirm request
// Clears the oldest intake event
// or ends the refill mode if active
void schedule_confirm_last_state()
{
  if (fill_time_active) {
    schedule_toggle_fill_time();
  }else{
    // Remove the oldest open intake time
    if (open_intakes.size() > 0) {
      JsonObject::iterator it = open_intakes.as<JsonObject>().begin();
      schedule_confirm(String(it->key().c_str()));
    }
  }
}


void schedule_confirm(String intakeId)
{
    debug("Removing key: " + intakeId);
    open_intakes.remove(intakeId);
    schedule_save();
    schedule_online_del_intake(intakeId);
    schedule_set_leds();
}


// Compares current time to 
// set intake times
// Generates new intake event 
// when matched
void schedule_check_for_new_intake()
{  
  int matched_schedule = 0;

  // Match current time against intake time
  if (schedule_check_match(get_setting("intakeMorning"))) {
    matched_schedule = SCHEDULE_MORNING;
    debug("Matched morning schedule");
  }

  if (schedule_check_match(get_setting("intakeMidday"))) {
    matched_schedule = SCHEDULE_MIDDAY;
    debug("Matched midday schedule");
  }
  
  if (schedule_check_match(get_setting("intakeEvening"))) {
    matched_schedule = SCHEDULE_EVENING;
    debug("Matched evening schedule");
  }

  if (schedule_check_match(get_setting("intakeNight"))) {
    matched_schedule = SCHEDULE_NIGHT;
    debug("Matched night schedule");
  }

  // Check for fillDay
  if (!fill_time_active) {
    if (tm.tm_wday == get_setting("fillDay").toInt()) {
      if (schedule_check_match(get_setting("fillTime"))) {
        if (schedule_get_current_intake_id() != last_matched_refill_id) {
          schedule_toggle_fill_time();
        }
      }
    }
  }

  if (matched_schedule) {
    String intake_id = schedule_get_current_intake_id();

    // Make sure current intake time has not already been processed
    if (schedule_get_unique_intake_id_from_intake_id(last_matched_intake_id) != schedule_get_unique_intake_id_from_intake_id(intake_id)) {
      debug("New schedule " + intake_id);
      last_matched_intake_id = intake_id;
      schedule_create_new_intake(intake_id, matched_schedule);
    }else{
      debug("Existing schedule - ignored");
    }
  }
}


// Generates a new intake event 
// in the open_intakes-object
void schedule_create_new_intake(String intake_id, int match_schedule)
{
  open_intakes[intake_id][SCHEDULE_INFO_WDAY]     = tm.tm_wday;
  open_intakes[intake_id][SCHEDULE_INFO_LED]      = schedule_get_led(tm.tm_wday, match_schedule);
  open_intakes[intake_id][SCHEDULE_INFO_SCHEDULE] = match_schedule;

  schedule_save();
  schedule_online_put_intake(intake_id);
  schedule_set_leds();
  schedule_send_intake_notification(intake_id);
}


String schedule_online_backend_server() 
{
  String server = get_setting("backendServer");
  server.toLowerCase();
  
  if (server.substring(0, 7) != "http://") {
    server = "http://" + server;
  }

  if (server.substring(server.length()-1, server.length()) != "/") {
    server += "/";
  }

  return server;
}


void schedule_online_put_intake(String intake_id)
{
  String url = schedule_online_backend_server() + "?put=" + intake_id;
  if (http_get(url).toInt()) {
    debug("Online PUT OK");
  }else{
    debug("Online PUT FAILED");
  }
}


void schedule_online_del_intake(String intake_id)
{
  String url = schedule_online_backend_server() + "?del=" + intake_id;
  if (http_get(url).toInt()) {
    debug("Online DEL OK");
  }else{
    debug("Online DEL FAILED");
  }
}


int schedule_online_get_intake_state(String intake_id)
{
  String url = schedule_online_backend_server() + "?get=" + intake_id;
  int res = http_get(url).toInt();

  if (res > -1) {
    return res;
  }else{
    return 0;
  }
}


// Checks whether any open intakes 
// have been confirmed on the backend server
void schedule_online_check_acks()
{
  debug("Checking for confirmed intakes on backend server");
  
  // Check reminder settings and number of open intakes
  if (open_intakes.size() > 0) {      
    String key   = "";
    String value = "";
    
    JsonObject intake_times_root = open_intakes.as<JsonObject>();

    for (JsonPair keyValue: intake_times_root) {
      key   = String(keyValue.key().c_str());

      if (schedule_online_get_intake_state(key)) {
        schedule_confirm(key);
      }      
    }
  }
}


// Sends an intake notification via the configured 
// notification method
void schedule_send_intake_notification(String intake_id) 
{
  String schedule_name = schedule_get_schedule_name(open_intakes[intake_id][SCHEDULE_INFO_SCHEDULE]);

  String notification_subject = "Erinnerung für Tabletteneinnahme (" + schedule_name + ")";
  
  String  notification_content = "Hallo " + get_setting("personalName") + ",\n\n" + 
                                 "es ist Zeit deine Medikamente am " + schedule_name + " einzunehmen!" + "\n\n" + 
                                 "Klicke auf den folgenden Link um die Einnahme zu bestätigen\n\n" +
                                 schedule_online_backend_server() + "?ack=" + intake_id;

  notification_send_mail(get_setting("notifyMail"), notification_subject, notification_content);
  notification_send_signal(notification_content);

  sound_play_melody();
}


// (De)Activates refill mode
void schedule_toggle_fill_time()
{
  fill_time_active       = !fill_time_active;
  last_matched_refill_id = schedule_get_current_intake_id();
  schedule_set_leds();

  if (fill_time_active) {
    schedule_send_fill_time_notification();
  }
}


// Sends refill notification
void schedule_send_fill_time_notification() 
{
  String notification_subject = "Es ist Zeit deine PillBox aufzufüllen";
  
  String notification_content = "Hallo " + get_setting("personalName") + ",\n\n" + 
                                "heute ist Auffülltag, bitte fülle deine PillBox auf!";

  notification_send_mail(get_setting("notifyMail"), notification_subject, notification_content);
  notification_send_signal(notification_content);

  sound_play_melody();
}


// Sends reminder notification for 
// unconfirmed intake events
void schedule_send_reminder_notification(String intake_id) 
{
  String schedule_name = schedule_get_schedule_name(open_intakes[intake_id][SCHEDULE_INFO_SCHEDULE]);
  String weekday_name  = schedule_get_weekday_name(open_intakes[intake_id][SCHEDULE_INFO_WDAY]);

  String notification_subject = "Erneute Erinnerung für Tabletteneinnahme (" + weekday_name + " " + schedule_name + ")";
  
  String notification_content = "Hallo " + get_setting("personalName") + ",\n\n" + 
                                "du hast die Einnahme deiner Medikamente von " + weekday_name + " " + schedule_name + " noch nicht bestätigt\n\n" + 
                                 "Klicke auf den folgenden Link um die Einnahme zu bestätigen\n\n" +
                                 schedule_online_backend_server() + "?ack=" + intake_id;

  notification_send_mail(get_setting("notifyMail"), notification_subject, notification_content);
  notification_send_signal(notification_content);

  sound_play_melody();
}


// Checks whether any new intake reminder
// notifacations need to be send
void schedule_send_open_intake_reminders()
{
  // Make sure reminders get checked only once per minute
  if (last_reminder_check_min != tm.tm_min) {
    debug("Checking for open intake reminders");

    int reminderInterval = get_setting("reminderInterval").toInt();

    last_reminder_check_min = tm.tm_min;
    
    // Check reminder settings and number of open intakes
    if (reminderInterval > 0 && open_intakes.size() > 0) {      
      String key   = "";
      String value = "";
      
      int intake_min = 0;
      
      JsonObject intake_times_root = open_intakes.as<JsonObject>();
  
      for (JsonPair keyValue: intake_times_root) {
        key   = String(keyValue.key().c_str());
        value = String(keyValue.value().as<char*>());

        // Make sure we are not in the same minute the intake_id was generated
        if (key != schedule_get_current_intake_id()) {
    
          intake_min = schedule_get_minutes_from_intake_id(key);
         
          // Check if its time to send a reminder
          if ((tm.tm_min - intake_min) % reminderInterval == 0) {
            debug("Sending open intake reminder for " + key);
            schedule_send_reminder_notification(key);
          }
        }
      }
    }
  }
}


// Sets the scheduling leds 
// according to the open intake events
void schedule_set_leds()
{
  led_reset();

  if (fill_time_active) {
      led_set_all(get_setting("fillTimeNotificationColor"));
      led_show();
  }else{

    int lastLED      = -1;
    int pastMatchLED = schedule_calculate_past_match_led();

    // Set LEDs of scheduled times that have already been confirmed
    for (int i = 0; i <= pastMatchLED; i++) {
      led_set_pixel(schedule_translate_led(i), get_setting("ledConfirmedIntakesColor"));
    }

    // Set LEDs of upcoming scheduled times
    for (int i = pastMatchLED+1; i < SCHEDULE_LED_COUNT; i++) {
      led_set_pixel(schedule_translate_led(i), get_setting("ledUpcomingIntakesColor"));
    }

    // Set LEDs of scheduled times that are currently open/unconfirmed
    if (open_intakes.size() > 0) {
      JsonObject intake_times_root = open_intakes.as<JsonObject>();
    
      for (JsonPair keyValue: intake_times_root) {
        lastLED = int(keyValue.value()[SCHEDULE_INFO_LED]);
        led_set_pixel(schedule_translate_led(lastLED), get_setting("ledMissedNotificationColor"));
      }

      // Highlight latest open schedule time
      if (lastLED > -1) {        
        led_set_pixel(schedule_translate_led(lastLED), get_setting("ledNewNotificationColor"));
      }
    }

    led_show();
  }
}


// Extracts the minute part from an intake ID
int schedule_get_minutes_from_intake_id(String intakeId)
{
  if (intakeId.length() >= INTAKE_ID_LEN) {
    return intakeId.substring(14, 16).toInt();
  }

  return 0;
}


// Extracts the unique part of an intake ID
String schedule_get_unique_intake_id_from_intake_id(String intakeId)
{
  if (intakeId.length() >= INTAKE_ID_LEN) {
    return intakeId.substring(0, UNIQUE_INTAKE_ID_LEN-1);
  }

  return "";
}


// Translate week day number 
// to week day name
String schedule_get_weekday_name(int wday) 
{
  switch (wday) {
    case 1: return "Montag";
    case 2: return "Dienstag";
    case 3: return "Mittwoch";
    case 4: return "Donnerstag";
    case 5: return "Freitag";
    case 6: return "Samstag";
    case 7: return "Sonntag";
    default: return "";
  }
}


// Translates schedule number
// to schedule name
String schedule_get_schedule_name(int schedule) 
{
  if (schedule == SCHEDULE_MORNING) {
    return "Morgen";
  }
  if (schedule == SCHEDULE_MIDDAY) {
    return "Mittag";
  }
  if (schedule == SCHEDULE_EVENING) {
    return "Abend";
  }
  if (schedule == SCHEDULE_NIGHT) {
    return "Nacht";
  }

  return "";
}


// Compares current time to given match time
bool schedule_check_match(String matchTime) {

  int matchTimeHours   = time_get_hours_from_time_string(matchTime).toInt();
  int matchTimeMinutes = time_get_minutes_from_time_string(matchTime).toInt();

  if (matchTimeHours == 0 && matchTimeMinutes == 0) {
    return false;
  }
  
  if (tm.tm_hour == matchTimeHours &&
      tm.tm_min  == matchTimeMinutes) {

    return true;        
  }
    
  return false;
}


// Checks whether a specific match time has alread passed
bool schedule_check_past_match(String matchTime) {

  int matchTimeHours   = time_get_hours_from_time_string(matchTime).toInt();
  int matchTimeMinutes = time_get_minutes_from_time_string(matchTime).toInt();

  if (matchTimeHours == 0 && matchTimeMinutes == 0) {
    return false;
  }
  
  if (tm.tm_hour > matchTimeHours ||
     (tm.tm_hour == matchTimeHours && tm.tm_min >= matchTimeMinutes)) {

    return true;        
  }

  return false;
}


// Generates a new intake ID
// based on the current time information
String schedule_get_current_intake_id() {
  return schedule_right_justify_string(String(tm.tm_year + 1900), 4, "0") + "_" + 
         schedule_right_justify_string(String(tm.tm_mon + 1)    , 2, "0") + "_" + 
         schedule_right_justify_string(String(tm.tm_mday)       , 2, "0") + "_" + 
         schedule_right_justify_string(String(tm.tm_hour)       , 2, "0") + "_" + 
         schedule_right_justify_string(String(tm.tm_min)        , 2, "0") + "_" + 
         schedule_right_justify_string(String(tm.tm_sec)        , 2, "0");
}


// Right justify a given string
String schedule_right_justify_string(String string, int len, String character)
{
  String result = "";
  
  if (string.length() < len) {
    len -= string.length();
    
    while (len--) {
      result += character;
    }
  }

  return result + string;
}


// Test LEDs in schedule order
void schedule_test_leds()
{
  for (int i = 0; i < 28; i++) {
    led_reset();
    led_set_pixel(schedule_translate_led(i), 0, 255, 0);
    led_show();
    delay(200);
  }

  schedule_set_leds();
}


// Save current schedule
void schedule_save()
{
  String schedule_json = "";
  serializeJson(open_intakes, schedule_json);
  
  if (file_write("/schedule.json", schedule_json)) {
    debug("Schedule save OK");
    debug(schedule_json);
  }else{
    debug("Schedule save FAILED");
  }
}


// Load last saved schedule
void schedule_load()
{
  String schedule_json = file_read("/schedule.json");

  if (schedule_json.length() > 0) {
    debug("Schedule load OK");
    debug(schedule_json);
  }else{
    debug("Schedule load FAILED");
  }

  deserializeJson(open_intakes, schedule_json);
  schedule_set_leds();
}


// Calculate last schedule that 
// was matched in the past and return the
// corresponding LED number
int schedule_calculate_past_match_led() 
{
  int lastPassedIntakeEvent = 0;

  if (schedule_check_past_match(get_setting("intakeMorning"))) {
    lastPassedIntakeEvent = SCHEDULE_MORNING;
  }

  if (schedule_check_past_match(get_setting("intakeMidday"))) {
    lastPassedIntakeEvent = SCHEDULE_MIDDAY;
  }

  if (schedule_check_past_match(get_setting("intakeEvening"))) {
    lastPassedIntakeEvent = SCHEDULE_EVENING;
  }

  if (schedule_check_past_match(get_setting("intakeNight"))) {
    lastPassedIntakeEvent = SCHEDULE_NIGHT;
  }

  int wday = tm.tm_wday;

  if (!lastPassedIntakeEvent) {
    lastPassedIntakeEvent = SCHEDULE_NIGHT;
    wday--;

    if (wday < 0) {
      wday = 6;
    }
  }

  return schedule_get_led(wday, lastPassedIntakeEvent);
}


int schedule_get_led(int wday, int intakeEvent) 
{ 
  return (((wday ? wday : 7) -1) * 4 + intakeEvent)-1;
}


int schedule_translate_led(int schedule_led) 
{
  int led_order_top_bottom[SCHEDULE_LED_COUNT] = { 3,  2,  1,  0,
                                                   4,  5,  6,  7,
                                                  11, 10,  9,  8,
                                                  12, 13, 14, 15,
                                                  19, 18, 17, 16,
                                                  20, 21, 22, 23,
                                                  27, 26, 25, 24};

  int led_order_bottom_top[SCHEDULE_LED_COUNT] = { 0,  1,  2,  3,
                                                   7,  6,  5,  4,
                                                   8,  9, 10, 11,
                                                  15, 14, 13, 12,
                                                  16, 17, 18, 19,
                                                  23, 22, 21, 20,
                                                  24, 25, 26, 27};

  if (schedule_led >= 0) {
    if (get_setting("ledOrder").toInt() == 1) {
      return led_order_bottom_top[schedule_led];
    }else{
      return led_order_top_bottom[schedule_led];
    }
  }

  return 0;
}
